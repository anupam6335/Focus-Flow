import mongoose from 'mongoose';

const todoItemSchema = new mongoose.Schema({
  _id: {
    type: mongoose.Schema.Types.ObjectId,
    default: () => new mongoose.Types.ObjectId()
  },
  title: {
    type: String,
    required: true,
    trim: true,
    maxlength: 200
  },
  notes: {
    type: String,
    trim: true,
    maxlength: 2000,
    default: ''
  },
  status: {
    type: String,
    enum: ['pending', 'done'],
    default: 'pending'
  },
  completed: {
    type: Boolean,
    default: false
  },
  dueDate: {
    type: String, // 'YYYY-MM-DD'
    required: true
  },
  sourceDate: {
    type: String, // 'YYYY-MM-DD' - the date the todo was first created
    required: true
  },
  order: {
    type: Number,
    default: 0,
    min: 0
  },
  autoGenerated: {
    type: Boolean,
    default: false
  },
  attachedToSandclock: {
    active: {
      type: Boolean,
      default: false
    },
    sessionId: {
      type: String,
      default: null
    }
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

const daySchema = new mongoose.Schema({
  date: {
    type: String, // 'YYYY-MM-DD'
    required: true
  },
  todos: [todoItemSchema]
});

const structuredTodoSchema = new mongoose.Schema({
  userId: {
    type: String,
    required: true,
    ref: 'User',
    index: true
  },
  days: [daySchema],
  lastProcessed: {
    type: String, // Last date when carry-over was processed (YYYY-MM-DD)
    default: null
  }
}, {
  timestamps: true
});

// Compound indexes for efficient querying
structuredTodoSchema.index({ userId: 1 });
structuredTodoSchema.index({ userId: 1, 'days.date': 1 });
structuredTodoSchema.index({ 'days.todos._id': 1 });
structuredTodoSchema.index({ 'days.todos.status': 1 });
structuredTodoSchema.index({ 'days.todos.dueDate': 1 });
structuredTodoSchema.index({ 'days.todos.attachedToSandclock.active': 1 });

// Virtual for user's todo count
structuredTodoSchema.virtual('totalTodos').get(function() {
  return this.days.reduce((total, day) => total + day.todos.length, 0);
});

// Method to get or create day
structuredTodoSchema.methods.getOrCreateDay = function(date) {
  let day = this.days.find(d => d.date === date);
  if (!day) {
    day = { date, todos: [] };
    this.days.push(day);
    this.markModified('days');
  }
  return day;
};
// Method to find todo by ID
structuredTodoSchema.methods.findTodoById = function(todoId) {
  for (const day of this.days) {
    const todo = day.todos.find(t => t._id.toString() === todoId.toString());
    if (todo) return { todo, day };
  }
  return null;
};

// Method to get todos for a specific date
structuredTodoSchema.methods.getTodosByDate = function(date) {
  const day = this.days.find(d => d.date === date);
  return day ? day.todos : [];
};

// Method to carry over pending todos to next day
structuredTodoSchema.methods.carryOverTodos = function(fromDate, toDate) {
  const fromDay = this.days.find(d => d.date === fromDate);
  if (!fromDay) return 0;

  const pendingTodos = fromDay.todos.filter(todo => 
    todo.status === 'pending' && !todo.completed
  );

  if (pendingTodos.length === 0) return 0;

  const toDay = this.getOrCreateDay(toDate);
  
  pendingTodos.forEach(todo => {
    // Create a new todo for the next day (don't modify the original)
    const carriedTodo = {
      ...todo.toObject(),
      _id: new mongoose.Types.ObjectId(),
      dueDate: toDate,
      sourceDate: todo.sourceDate, // Keep original source date
      order: toDay.todos.length,
      attachedToSandclock: { active: false, sessionId: null },
      createdAt: new Date(),
      updatedAt: new Date()
    };
    toDay.todos.push(carriedTodo);
  });

  this.lastProcessed = toDate;
  return pendingTodos.length;
};

// Static method to get or create user's structured todos
structuredTodoSchema.statics.getUserTodos = async function(userId, ensureToday = false) {
  let userTodos = await this.findOne({ userId });
  
  if (!userTodos) {
    userTodos = new this({
      userId,
      days: []
    });
  }
  
  // Optionally ensure today's day exists
  if (ensureToday) {
    const today = new Date().toISOString().split('T')[0];
    userTodos.getOrCreateDay(today);
  }
  
  return userTodos;
};

// Static method to process daily carry-over for all users
structuredTodoSchema.statics.processDailyCarryOver = async function() {
  const today = new Date().toISOString().split('T')[0];
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString().split('T')[0];

  // Find all users who haven't been processed today
  const userTodos = await this.find({
    $or: [
      { lastProcessed: { $ne: today } },
      { lastProcessed: null }
    ]
  });

  let totalCarriedOver = 0;
  let processedUsers = 0;

  for (const userTodo of userTodos) {
    const carriedCount = userTodo.carryOverTodos(yesterdayStr, today);
    if (carriedCount > 0) {
      await userTodo.save();
      totalCarriedOver += carriedCount;
    }
    processedUsers++;
  }

  return {
    processedUsers,
    totalCarriedOver,
    date: today
  };
};

export default mongoose.model('StructuredTodo', structuredTodoSchema);