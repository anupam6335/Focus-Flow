import express from 'express';
import StructuredTodo from '../models/StructuredTodo.js';
import { authenticateToken } from '../middleware/auth.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { validateTodo, validateBulkUpdate } from '../middleware/validation.js';

const router = express.Router();

// Helper function to format todo for response
const formatTodoResponse = (todo) => ({
  _id: todo._id,
  title: todo.title,
  notes: todo.notes,
  status: todo.status,
  dueDate: todo.dueDate,
  sourceDate: todo.sourceDate,
  order: todo.order,
  autoGenerated: todo.autoGenerated,
  attachedToSandclock: todo.attachedToSandclock,
  createdAt: todo.createdAt,
  updatedAt: todo.updatedAt
});


// Helper function to ensure day exists
const ensureDayExists = (userTodos, date) => {
  let day = userTodos.days.find(d => d.date === date);
  if (!day) {
    day = { date, todos: [] };
    userTodos.days.push(day);
    userTodos.markModified('days');
  }
  return day;
};

// Apply validation middleware
router.post('/', authenticateToken, validateTodo, asyncHandler(createTodo));
router.patch('/:id', authenticateToken, validateTodo, asyncHandler(updateTodo));
router.patch('/', authenticateToken, validateBulkUpdate, asyncHandler(bulkUpdate));


/**
 * @route   GET /api/todos
 * @desc    Get todos for a specific date (default: today)
 * @access  Private
 */
router.get('/', authenticateToken, asyncHandler(async (req, res) => {
  const { date = new Date().toISOString().split('T')[0] } = req.query;
  const userId = req.user.username;

  // Validate date format
  if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid date format. Use YYYY-MM-DD'
    });
  }

  const userTodos = await StructuredTodo.getUserTodos(userId);
  
  // AUTO-CREATE THE DAY IF IT DOESN'T EXIST
  const day = ensureDayExists(userTodos, date);
  
  // Save if we created a new day
  if (userTodos.isModified()) {
    await userTodos.save();
  }

  const todos = day.todos
    .sort((a, b) => a.order - b.order)
    .map(formatTodoResponse);

  res.json({
    success: true,
    todos,
    date,
    count: todos.length
  });
}));
/**
 * @route   GET /api/todos/history
 * @desc    Get todos from previous days with comprehensive filtering
 * @access  Private
 */
router.get('/history', authenticateToken, asyncHandler(async (req, res) => {
  const { 
    before, 
    after, 
    includeDone = false, 
    limit = 20, 
    cursor,
    groupByDate = false 
  } = req.query;
  
  const userId = req.user.username;
  const userTodos = await StructuredTodo.getUserTodos(userId);
  
  // Filter days by date range
  let filteredDays = userTodos.days.filter(day => {
    if (before && day.date >= before) return false;
    if (after && day.date < after) return false;
    return true;
  });

  // Sort days by date (newest first)
  filteredDays.sort((a, b) => b.date.localeCompare(a.date));

  // Flatten todos with day information
  let allTodos = [];
  filteredDays.forEach(day => {
    let dayTodos = day.todos;
    
    if (!includeDone) {
      dayTodos = dayTodos.filter(todo => todo.status === 'pending');
    }
    
    dayTodos.forEach(todo => {
      allTodos.push({
        ...formatTodoResponse(todo),
        dayDate: day.date
      });
    });
  });

  // Apply cursor pagination
  if (cursor) {
    const cursorIndex = allTodos.findIndex(todo => todo._id.toString() === cursor);
    if (cursorIndex !== -1) {
      allTodos = allTodos.slice(cursorIndex + 1);
    }
  }

  const hasMore = allTodos.length > parseInt(limit);
  const resultTodos = hasMore ? allTodos.slice(0, parseInt(limit)) : allTodos;

  if (groupByDate) {
    const grouped = resultTodos.reduce((acc, todo) => {
      const date = todo.dayDate;
      if (!acc[date]) acc[date] = [];
      acc[date].push(todo);
      return acc;
    }, {});
    
    return res.json({
      success: true,
      todos: grouped,
      nextCursor: hasMore ? resultTodos[resultTodos.length - 1]._id : null,
      total: resultTodos.length
    });
  }
  
  res.json({
    success: true,
    todos: resultTodos,
    nextCursor: hasMore ? resultTodos[resultTodos.length - 1]._id : null,
    total: resultTodos.length
  });
}));

/**
 * @route   GET /api/todos/carry-overs
 * @desc    Get carry-over todos (previous days) with pagination
 * @access  Private
 */
router.get('/carry-overs', authenticateToken, asyncHandler(async (req, res) => {
  const { cursor, limit = 20, includeDone = false } = req.query;
  const userId = req.user.username;
  const today = new Date().toISOString().split('T')[0];

  const userTodos = await StructuredTodo.getUserTodos(userId);
  
  // Get todos from previous days
  const previousDays = userTodos.days.filter(day => day.date < today);
  
  let carryOverTodos = [];
  previousDays.forEach(day => {
    let dayTodos = day.todos;
    
    if (!includeDone) {
      dayTodos = dayTodos.filter(todo => todo.status === 'pending');
    }
    
    dayTodos.forEach(todo => {
      carryOverTodos.push({
        ...formatTodoResponse(todo),
        dayDate: day.date
      });
    });
  });

  // Sort by date (oldest first) so oldest carry-overs appear first
  carryOverTodos.sort((a, b) => a.dayDate.localeCompare(b.dayDate));

  // Apply cursor pagination
  if (cursor) {
    const cursorIndex = carryOverTodos.findIndex(todo => todo._id.toString() === cursor);
    if (cursorIndex !== -1) {
      carryOverTodos = carryOverTodos.slice(cursorIndex + 1);
    }
  }

  const hasMore = carryOverTodos.length > parseInt(limit);
  const resultTodos = hasMore ? carryOverTodos.slice(0, parseInt(limit)) : carryOverTodos;

  res.json({
    success: true,
    todos: resultTodos,
    nextCursor: hasMore ? resultTodos[resultTodos.length - 1]._id : null
  });
}));

/**
 * @route   POST /api/todos
 * @desc    Create a new todo
 * @access  Private
 */
async function createTodo(req, res) {
  const { title, notes, dueDate = new Date().toISOString().split('T')[0] } = req.body;
  const userId = req.user.username;

  const userTodos = await StructuredTodo.getUserTodos(userId);
  
  // AUTO-CREATE THE DAY IF IT DOESN'T EXIST
  const day = ensureDayExists(userTodos, dueDate);

  // Get the next order number for the dueDate
  const lastOrder = day.todos.length > 0 
    ? Math.max(...day.todos.map(t => t.order)) 
    : -1;

  const newTodo = {
    title,
    notes: notes || '',
    dueDate,
    sourceDate: dueDate,
    order: lastOrder + 1,
    autoGenerated: false,
    completed: false,
    status: 'pending'
  };

  day.todos.push(newTodo);
  await userTodos.save();

  const savedTodo = day.todos[day.todos.length - 1];

  res.status(201).json({
    success: true,
    todo: formatTodoResponse(savedTodo)
  });
}

/**
 * @route   POST /api/todos/auto-generate
 * @desc    Auto-generate 3 unique todos for today - AUTO-CREATES DAY IF NOT EXISTS
 * @access  Private
 */
router.post('/auto-generate', authenticateToken, asyncHandler(async (req, res) => {
  const userId = req.user.username;
  const dueDate = new Date().toISOString().split('T')[0];

  const userTodos = await StructuredTodo.getUserTodos(userId);
  
  // AUTO-CREATE THE DAY IF IT DOESN'T EXIST
  const day = ensureDayExists(userTodos, dueDate);

  // Check if already auto-generated exactly 3 todos today
  const existingAutoGeneratedCount = day.todos.filter(todo => todo.autoGenerated).length;

  if (existingAutoGeneratedCount >= 3) {
    return res.status(400).json({
      success: false,
      error: 'Auto-generated todos already created for today'
    });
  }

  // If some exist but less than 3, delete them to ensure consistency
  if (existingAutoGeneratedCount > 0) {
    day.todos = day.todos.filter(todo => !todo.autoGenerated);
  }

  // Get the next order number
  const lastOrder = day.todos.length > 0 
    ? Math.max(...day.todos.map(t => t.order)) 
    : -1;

  let order = lastOrder + 1;

  const autoTodos = [
    {
      title: 'Review yesterday\'s progress',
      notes: 'Spend 10 minutes reviewing what you accomplished yesterday and what could be improved.',
      dueDate,
      sourceDate: dueDate,
      order: order++,
      autoGenerated: true,
      completed: false,
      status: 'pending'
    },
    {
      title: 'Plan today\'s top priorities',
      notes: 'Identify and focus on the 2-3 most important tasks for today.',
      dueDate,
      sourceDate: dueDate,
      order: order++,
      autoGenerated: true,
      completed: false,
      status: 'pending'
    },
    {
      title: 'Take mindful breaks',
      notes: 'Remember to take short breaks to maintain focus and productivity throughout the day.',
      dueDate,
      sourceDate: dueDate,
      order: order++,
      autoGenerated: true,
      completed: false,
      status: 'pending'
    }
  ];

  autoTodos.forEach(todo => day.todos.push(todo));
  await userTodos.save();

  // Get the newly created todos
  const newTodos = day.todos.slice(-3).map(formatTodoResponse);

  res.status(201).json({
    success: true,
    todos: newTodos,
    message: 'Auto-generated todos created successfully'
  });
}));

/**
 * @route   PATCH /api/todos/:id
 * @desc    Update a todo
 * @access  Private
 */
async function updateTodo(req, res) {
  const { id } = req.params;
  const userId = req.user.username;
  const updates = req.body;

  // Remove immutable fields
  delete updates.userId;
  delete updates._id;
  delete updates.autoGenerated;
  delete updates.sourceDate;

  const userTodos = await StructuredTodo.getUserTodos(userId);
  const result = userTodos.findTodoById(id);

  if (!result) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  const { todo, day } = result;

  // Update fields
  Object.keys(updates).forEach(key => {
    if (key in todo) {
      todo[key] = updates[key];
    }
  });

  // Sync completed field with status
  if (updates.status !== undefined) {
    todo.completed = updates.status === 'done';
  } else if (updates.completed !== undefined) {
    todo.status = updates.completed ? 'done' : 'pending';
  }

  todo.updatedAt = new Date();
  userTodos.markModified('days'); // Mark as modified

  await userTodos.save();

  res.json({
    success: true,
    todo: formatTodoResponse(todo)
  });
}

/**
 * @route   PATCH /api/todos
 * @desc    Bulk update todos (for reordering)
 * @access  Private
 */
async function bulkUpdate(req, res) {
  const { updates } = req.body;
  const userId = req.user.username;

  const userTodos = await StructuredTodo.getUserTodos(userId);
  let modifiedCount = 0;

  updates.forEach(({ id, order }) => {
    const result = userTodos.findTodoById(id);
    if (result && result.todo.order !== order) {
      result.todo.order = order;
      result.todo.updatedAt = new Date();
      modifiedCount++;
    }
  });

  await userTodos.save();

  res.json({
    success: true,
    message: `${modifiedCount} todos updated successfully`,
    modifiedCount
  });
}

/**
 * @route   DELETE /api/todos/:id
 * @desc    Delete a todo
 * @access  Private
 */
router.delete('/:id', authenticateToken, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.username;

  const userTodos = await StructuredTodo.getUserTodos(userId);
  let deletedTodo = null;

  // Find and remove the todo
  for (const day of userTodos.days) {
    const todoIndex = day.todos.findIndex(t => t._id.toString() === id);
    if (todoIndex !== -1) {
      deletedTodo = day.todos[todoIndex];
      day.todos.splice(todoIndex, 1);
      break;
    }
  }

  if (!deletedTodo) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  await userTodos.save();

  res.json({
    success: true,
    message: 'Todo deleted successfully',
    deletedTodo: {
      id: deletedTodo._id,
      title: deletedTodo.title
    }
  });
}));

/**
 * @route   POST /api/todos/:id/attach
 * @desc    Attach a todo to the current sandclock session
 * @access  Private
 */
router.post('/:id/attach', authenticateToken, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.username;
  const { sessionId } = req.body;

  if (!sessionId) {
    return res.status(400).json({
      success: false,
      error: 'Session ID is required'
    });
  }

  const userTodos = await StructuredTodo.getUserTodos(userId);

  // First, detach any currently attached todo
  for (const day of userTodos.days) {
    for (const todo of day.todos) {
      if (todo.attachedToSandclock.active) {
        todo.attachedToSandclock.active = false;
        todo.attachedToSandclock.sessionId = null;
        todo.updatedAt = new Date();
      }
    }
  }

  const result = userTodos.findTodoById(id);
  if (!result) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  const { todo } = result;
  todo.attachedToSandclock.active = true;
  todo.attachedToSandclock.sessionId = sessionId;
  todo.updatedAt = new Date();

  await userTodos.save();

  res.json({
    success: true,
    todo: formatTodoResponse(todo),
    message: 'Todo attached to sandclock session'
  });
}));

/**
 * @route   POST /api/todos/:id/detach
 * @desc    Detach a todo from the current sandclock session
 * @access  Private
 */
router.post('/:id/detach', authenticateToken, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.username;

  const userTodos = await StructuredTodo.getUserTodos(userId);
  const result = userTodos.findTodoById(id);

  if (!result) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  const { todo } = result;
  todo.attachedToSandclock.active = false;
  todo.attachedToSandclock.sessionId = null;
  todo.updatedAt = new Date();

  await userTodos.save();

  res.json({
    success: true,
    todo: formatTodoResponse(todo),
    message: 'Todo detached from sandclock session'
  });
}));

/**
 * @route   POST /api/todos/:id/complete-from-sandclock
 * @desc    Mark a todo as done from sandclock session completion
 * @access  Private
 */
router.post('/:id/complete-from-sandclock', authenticateToken, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.username;

  const userTodos = await StructuredTodo.getUserTodos(userId);
  const result = userTodos.findTodoById(id);

  if (!result) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  const { todo } = result;
  todo.status = 'done';
  todo.completed = true;
  todo.attachedToSandclock.active = false;
  todo.attachedToSandclock.sessionId = null;
  todo.updatedAt = new Date();

  await userTodos.save();

  res.json({
    success: true,
    todo: formatTodoResponse(todo),
    message: 'Todo marked as completed from sandclock session'
  });
}));

/**
 * @route   GET /api/todos/stats
 * @desc    Get todo statistics for user
 * @access  Private
 */
router.get('/stats', authenticateToken, asyncHandler(async (req, res) => {
  const userId = req.user.username;
  const today = new Date().toISOString().split('T')[0];

  const userTodos = await StructuredTodo.getUserTodos(userId);

  let totalTodos = 0;
  let completedTodos = 0;
  let todayTotal = 0;
  let todayCompleted = 0;
  const byStatus = { pending: 0, done: 0 };

  userTodos.days.forEach(day => {
    day.todos.forEach(todo => {
      totalTodos++;
      if (todo.status === 'done') {
        completedTodos++;
        byStatus.done++;
      } else {
        byStatus.pending++;
      }

      if (day.date === today) {
        todayTotal++;
        if (todo.status === 'done') {
          todayCompleted++;
        }
      }
    });
  });

  const recentActivity = userTodos.days
    .flatMap(day => day.todos)
    .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))
    .slice(0, 10)
    .map(todo => ({
      _id: todo._id,
      title: todo.title,
      status: todo.status,
      dueDate: todo.dueDate,
      updatedAt: todo.updatedAt
    }));

  res.json({
    success: true,
    stats: {
      total: totalTodos,
      completed: completedTodos,
      completionRate: totalTodos > 0 ? Math.round((completedTodos / totalTodos) * 100) : 0,
      today: {
        total: todayTotal,
        completed: todayCompleted,
        pending: todayTotal - todayCompleted
      },
      byStatus,
      recentActivity
    }
  });
}));

export default router;