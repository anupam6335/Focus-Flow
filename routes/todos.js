import express from 'express';
import Todo from '../models/Todo.js';
import { authenticateToken } from '../middleware/auth.js';
import { asyncHandler } from '../middleware/errorHandler.js';
import { validateTodo, validateBulkUpdate } from '../middleware/validation.js';
import { checkAndSendNotifications } from '../services/notificationService.js';

const router = express.Router();

// Apply validation middleware
router.post('/', authenticateToken, validateTodo, asyncHandler(createTodo));
router.patch('/:id', authenticateToken, validateTodo, asyncHandler(updateTodo));
router.patch('/', authenticateToken, validateBulkUpdate, asyncHandler(bulkUpdate));

/**
 * @route   GET /api/todos
 * @desc    Get todos for a specific date (default: today)
 * @access  Private
 */
router.get('/', authenticateToken, asyncHandler(async (req, res) => {
  const { date = new Date().toISOString().split('T')[0] } = req.query;
  const userId = req.user.username;

  // Validate date format
  if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid date format. Use YYYY-MM-DD'
    });
  }

  const todos = await Todo.find({ userId, dueDate: date })
    .select('_id title notes status order dueDate sourceDate autoGenerated attachedToSandclock createdAt updatedAt')
    .sort({ order: 1, createdAt: 1 })
    .lean();

  res.json({
    success: true,
    todos,
    date,
    count: todos.length
  });
}));

/**
 * @route   GET /api/todos/history
 * @desc    Get todos from previous days with comprehensive filtering
 * @access  Private
 */
router.get('/history', authenticateToken, asyncHandler(async (req, res) => {
  const { 
    before, 
    after, 
    includeDone = false, 
    limit = 20, 
    cursor,
    groupByDate = false 
  } = req.query;
  
  const userId = req.user.username;
  let query = { userId };
  
  // Date range filters
  if (before || after) {
    query.dueDate = {};
    if (before) query.dueDate.$lt = before;
    if (after) query.dueDate.$gte = after;
  } else {
    // Default to previous days if no range specified
    const today = new Date().toISOString().split('T')[0];
    query.dueDate = { $lt: today };
  }
  
  if (!includeDone) {
    query.status = 'pending';
  }
  
  // Cursor-based pagination
  if (cursor) {
    query._id = { $lt: cursor };
  }
  
  const todos = await Todo.find(query)
    .select('_id title notes status dueDate sourceDate autoGenerated order createdAt updatedAt')
    .sort({ dueDate: -1, order: 1 })
    .limit(parseInt(limit) + 1) // Get one extra to check for next cursor
    .lean();
  
  const hasMore = todos.length > parseInt(limit);
  if (hasMore) {
    todos.pop(); // Remove the extra item
  }
  
  if (groupByDate) {
    const grouped = todos.reduce((acc, todo) => {
      const date = todo.dueDate;
      if (!acc[date]) acc[date] = [];
      acc[date].push(todo);
      return acc;
    }, {});
    
    return res.json({
      success: true,
      todos: grouped,
      nextCursor: hasMore ? todos[todos.length - 1]._id : null,
      total: todos.length
    });
  }
  
  res.json({
    success: true,
    todos,
    nextCursor: hasMore ? todos[todos.length - 1]._id : null,
    total: todos.length
  });
}));

/**
 * @route   GET /api/todos/carry-overs
 * @desc    Get carry-over todos (previous days) with pagination
 * @access  Private
 */
router.get('/carry-overs', authenticateToken, asyncHandler(async (req, res) => {
  const { cursor, limit = 20, includeDone = false } = req.query;
  const userId = req.user.username;

  let query = { 
    userId, 
    dueDate: { $lt: new Date().toISOString().split('T')[0] } 
  };

  if (!includeDone) {
    query.status = 'pending';
  }

  if (cursor) {
    query._id = { $lt: cursor };
  }

  const todos = await Todo.find(query)
    .select('_id title notes status dueDate sourceDate autoGenerated order createdAt')
    .sort({ dueDate: -1, order: 1 })
    .limit(parseInt(limit) + 1)
    .lean();

  const hasMore = todos.length > parseInt(limit);
  const resultTodos = hasMore ? todos.slice(0, -1) : todos;

  res.json({
    success: true,
    todos: resultTodos,
    nextCursor: hasMore ? resultTodos[resultTodos.length - 1]._id : null
  });
}));

/**
 * @route   POST /api/todos
 * @desc    Create a new todo
 * @access  Private
 */
async function createTodo(req, res) {
  const { title, notes, dueDate = new Date().toISOString().split('T')[0] } = req.body;
  const userId = req.user.username;

  // Get the next order number for the dueDate
  const lastTodo = await Todo.findOne({ userId, dueDate })
    .sort({ order: -1 })
    .select('order')
    .lean();

  const order = (lastTodo?.order || 0) + 1;

  const todo = new Todo({
    userId,
    title,
    notes: notes || '',
    dueDate,
    sourceDate: dueDate,
    order,
    autoGenerated: false
  });

  await todo.save();

  res.status(201).json({
    success: true,
    todo: await Todo.findById(todo._id).lean()
  });
}

/**
 * @route   POST /api/todos/auto-generate
 * @desc    Auto-generate 3 unique todos for today
 * @access  Private
 */
router.post('/auto-generate', authenticateToken, asyncHandler(async (req, res) => {
  const userId = req.user.username;
  const dueDate = new Date().toISOString().split('T')[0];

  // Check if already auto-generated exactly 3 todos today
  const existingAutoGeneratedCount = await Todo.countDocuments({ 
    userId, 
    dueDate, 
    autoGenerated: true 
  });

  if (existingAutoGeneratedCount >= 3) {
    return res.status(400).json({
      success: false,
      error: 'Auto-generated todos already created for today'
    });
  }

  // If some exist but less than 3, delete them to ensure consistency
  if (existingAutoGeneratedCount > 0) {
    await Todo.deleteMany({ userId, dueDate, autoGenerated: true });
  }

  // Get the next order number
  const lastTodo = await Todo.findOne({ userId, dueDate })
    .sort({ order: -1 })
    .select('order')
    .lean();

  let order = (lastTodo?.order || 0) + 1;

  const autoTodos = [
    {
      title: 'Review yesterday\'s progress',
      notes: 'Spend 10 minutes reviewing what you accomplished yesterday and what could be improved.',
      dueDate,
      sourceDate: dueDate,
      order: order++,
      autoGenerated: true
    },
    {
      title: 'Plan today\'s top priorities',
      notes: 'Identify and focus on the 2-3 most important tasks for today.',
      dueDate,
      sourceDate: dueDate,
      order: order++,
      autoGenerated: true
    },
    {
      title: 'Take mindful breaks',
      notes: 'Remember to take short breaks to maintain focus and productivity throughout the day.',
      dueDate,
      sourceDate: dueDate,
      order: order++,
      autoGenerated: true
    }
  ];

  const todos = await Todo.insertMany(autoTodos.map(todo => ({ ...todo, userId })));

  res.status(201).json({
    success: true,
    todos: await Todo.find({ _id: { $in: todos.map(t => t._id) } }).lean(),
    message: 'Auto-generated todos created successfully'
  });
}));

/**
 * @route   PATCH /api/todos/:id
 * @desc    Update a todo
 * @access  Private
 */
async function updateTodo(req, res) {
  const { id } = req.params;
  const userId = req.user.username;
  const updates = req.body;

  // Remove immutable fields
  delete updates.userId;
  delete updates._id;
  delete updates.autoGenerated;
  delete updates.sourceDate;

  const todo = await Todo.findOneAndUpdate(
    { _id: id, userId },
    { ...updates, updatedAt: new Date() },
    { new: true, runValidators: true }
  );

  if (!todo) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  if (updates.status === 'done') {
    await checkAndSendNotifications(userId, { todoCompleted: true });
  }

  res.json({
    success: true,
    todo: todo.toObject()
  });
}

/**
 * @route   PATCH /api/todos
 * @desc    Bulk update todos (for reordering)
 * @access  Private
 */
async function bulkUpdate(req, res) {
  const { updates } = req.body;
  const userId = req.user.username;

  const operations = updates.map(({ id, order }) => ({
    updateOne: {
      filter: { _id: id, userId },
      update: { $set: { order, updatedAt: new Date() } }
    }
  }));

  const result = await Todo.bulkWrite(operations);

  res.json({
    success: true,
    message: `${result.modifiedCount} todos updated successfully`,
    modifiedCount: result.modifiedCount
  });
}

/**
 * @route   DELETE /api/todos/:id
 * @desc    Delete a todo
 * @access  Private
 */
router.delete('/:id', authenticateToken, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.username;

  const todo = await Todo.findOneAndDelete({ _id: id, userId });

  if (!todo) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  res.json({
    success: true,
    message: 'Todo deleted successfully',
    deletedTodo: {
      id: todo._id,
      title: todo.title
    }
  });
}));

/**
 * @route   POST /api/todos/:id/attach
 * @desc    Attach a todo to the current sandclock session
 * @access  Private
 */
router.post('/:id/attach', authenticateToken, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.username;
  const { sessionId } = req.body;

  if (!sessionId) {
    return res.status(400).json({
      success: false,
      error: 'Session ID is required'
    });
  }

  // First, detach any currently attached todo
  await Todo.updateMany(
    { userId, 'attachedToSandclock.active': true },
    { 
      'attachedToSandclock.active': false,
      'attachedToSandclock.sessionId': null,
      updatedAt: new Date()
    }
  );

  const todo = await Todo.findOneAndUpdate(
    { _id: id, userId },
    { 
      'attachedToSandclock.active': true,
      'attachedToSandclock.sessionId': sessionId,
      updatedAt: new Date()
    },
    { new: true }
  );

  if (!todo) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  res.json({
    success: true,
    todo: todo.toObject(),
    message: 'Todo attached to sandclock session'
  });
}));

/**
 * @route   POST /api/todos/:id/detach
 * @desc    Detach a todo from the current sandclock session
 * @access  Private
 */
router.post('/:id/detach', authenticateToken, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.username;

  const todo = await Todo.findOneAndUpdate(
    { _id: id, userId },
    { 
      'attachedToSandclock.active': false,
      'attachedToSandclock.sessionId': null,
      updatedAt: new Date()
    },
    { new: true }
  );

  if (!todo) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  res.json({
    success: true,
    todo: todo.toObject(),
    message: 'Todo detached from sandclock session'
  });
}));

/**
 * @route   POST /api/todos/:id/complete-from-sandclock
 * @desc    Mark a todo as done from sandclock session completion
 * @access  Private
 */
router.post('/:id/complete-from-sandclock', authenticateToken, asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.user.username;

  const todo = await Todo.findOneAndUpdate(
    { _id: id, userId },
    { 
      status: 'done',
      'attachedToSandclock.active': false,
      'attachedToSandclock.sessionId': null,
      updatedAt: new Date()
    },
    { new: true }
  );

  if (!todo) {
    return res.status(404).json({
      success: false,
      error: 'Todo not found'
    });
  }

  await checkAndSendNotifications(userId, {todoComplete: true} );

  res.json({
    success: true,
    todo: todo.toObject(),
    message: 'Todo marked as completed from sandclock session'
  });
}));

/**
 * @route   GET /api/todos/stats
 * @desc    Get todo statistics for user
 * @access  Private
 */
router.get('/stats', authenticateToken, asyncHandler(async (req, res) => {
  const userId = req.user.username;
  const today = new Date().toISOString().split('T')[0];

  const stats = await Todo.aggregate([
    { $match: { userId } },
    {
      $facet: {
        totalTodos: [
          { $count: 'count' }
        ],
        completedTodos: [
          { $match: { status: 'done' } },
          { $count: 'count' }
        ],
        todayTodos: [
          { $match: { dueDate: today } },
          { $count: 'count' }
        ],
        todayCompleted: [
          { $match: { dueDate: today, status: 'done' } },
          { $count: 'count' }
        ],
        byStatus: [
          { $group: { _id: '$status', count: { $sum: 1 } } }
        ],
        recentActivity: [
          { $sort: { updatedAt: -1 } },
          { $limit: 10 },
          {
            $project: {
              title: 1,
              status: 1,
              dueDate: 1,
              updatedAt: 1
            }
          }
        ]
      }
    }
  ]);

  const result = stats[0];
  const total = result.totalTodos[0]?.count || 0;
  const completed = result.completedTodos[0]?.count || 0;
  const todayTotal = result.todayTodos[0]?.count || 0;
  const todayCompleted = result.todayCompleted[0]?.count || 0;

  res.json({
    success: true,
    stats: {
      total,
      completed,
      completionRate: total > 0 ? Math.round((completed / total) * 100) : 0,
      today: {
        total: todayTotal,
        completed: todayCompleted,
        pending: todayTotal - todayCompleted
      },
      byStatus: result.byStatus.reduce((acc, item) => {
        acc[item._id] = item.count;
        return acc;
      }, {}),
      recentActivity: result.recentActivity
    }
  });
}));

export default router;